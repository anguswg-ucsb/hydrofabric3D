[{"path":"/LICENSE.html","id":null,"dir":"","previous_headings":"","what":"MIT License","title":"MIT License","text":"Copyright (c) 2023 hydrofabric3D authors Permission hereby granted, free charge, person obtaining copy software associated documentation files (“Software”), deal Software without restriction, including without limitation rights use, copy, modify, merge, publish, distribute, sublicense, /sell copies Software, permit persons Software furnished , subject following conditions: copyright notice permission notice shall included copies substantial portions Software. SOFTWARE PROVIDED “”, WITHOUT WARRANTY KIND, EXPRESS IMPLIED, INCLUDING LIMITED WARRANTIES MERCHANTABILITY, FITNESS PARTICULAR PURPOSE NONINFRINGEMENT. EVENT SHALL AUTHORS COPYRIGHT HOLDERS LIABLE CLAIM, DAMAGES LIABILITY, WHETHER ACTION CONTRACT, TORT OTHERWISE, ARISING , CONNECTION SOFTWARE USE DEALINGS SOFTWARE.","code":""},{"path":"/articles/basic_use.html","id":"installation","dir":"Articles","previous_headings":"","what":"Installation","title":"Basic Use","text":"can install development version hydrofabric3D GitHub :","code":"# install.packages(\"devtools\") devtools::install_github(\"mikejohnson51/hydrofabric3D\")"},{"path":"/articles/basic_use.html","id":"example","dir":"Articles","previous_headings":"","what":"Example","title":"Basic Use","text":"basic example shows cut cross sections network.","code":""},{"path":"/articles/basic_use.html","id":"define-network","dir":"Articles","previous_headings":"Example","what":"Define Network","title":"Basic Use","text":"","code":"library(hydrofabric3D) library(dplyr) #>  #> Attaching package: 'dplyr' #> The following objects are masked from 'package:stats': #>  #>     filter, lag #> The following objects are masked from 'package:base': #>  #>     intersect, setdiff, setequal, union  (net = linestring %>%    mutate(bf_width = exp(0.700    + 0.365* log(totdasqkm)))) #> Simple feature collection with 325 features and 5 fields #> Geometry type: LINESTRING #> Dimension:     XY #> Bounding box:  xmin: 77487.09 ymin: 890726.5 xmax: 130307.4 ymax: 939129.8 #> Projected CRS: NAD83 / Conus Albers #> # A tibble: 325 × 6 #>    nhdplus_comid                       geometry  comid totdasqkm dist_m bf_width #>  * <chr>                       <LINESTRING [m]>  <dbl>     <dbl>  <dbl>    <dbl> #>  1 101           (128525.6 892408.3, 128565.7 … 1.01e2  7254.    3.25e3   51.7   #>  2 24599575      (128084.7 892952.4, 128525.6 … 2.46e7  7249.    7.00e2   51.6   #>  3 1078635       (127687.6 893270.4, 127799.7 … 1.08e6  7248.    5.22e2   51.6   #>  4 1078637       (124942.8 893959.6, 124948.2 … 1.08e6    68.2   4.17e3    9.41  #>  5 1078639       (125523.1 892528, 125657.3 89… 1.08e6  7180.    2.76e3   51.5   #>  6 1078577       (123219.9 902292.8, 123233.5 … 1.08e6    19.8   9.91e3    5.99  #>  7 1078575       (121975.5 909050.8, 122028.9 … 1.08e6    41.3   1.87e4    7.83  #>  8 1078657       (124263.8 892410.4, 124420.6 … 1.08e6  7179.    1.66e3   51.5   #>  9 1078663       (125628.9 892216, 125555.7 89… 1.08e6     0.099 7.54e2    0.866 #> 10 1078643       (124248.1 892440.7, 124263.8 … 1.08e6  7178.    3.41e1   51.5   #> # ℹ 315 more rows   plot(net$geometry)"},{"path":"/articles/basic_use.html","id":"cut-cross-sections","dir":"Articles","previous_headings":"Example","what":"Cut cross sections","title":"Basic Use","text":"","code":"(transects = cut_cross_sections(net = net,                          id = \"comid\",                           cs_widths = pmax(50, net$bf_width * 7),                          num = 10) ) #> Smoothing #> Densifying #> Cutting #> Formating #> Warning: st_centroid assumes attributes are constant over geometries #> Simple feature collection with 2275 features and 7 fields #> Geometry type: LINESTRING #> Dimension:     XY #> Bounding box:  xmin: 77473.82 ymin: 890553.2 xmax: 130336.7 ymax: 939136.7 #> Projected CRS: NAD83 / Conus Albers #> # A tibble: 2,275 × 8 #>    ds_distance cs_measure    hy_id cs_widths                      geometry cs_id #>          <dbl>      <dbl>    <dbl>     <dbl>              <LINESTRING [m]> <int> #>  1       367.        11.2      101      362. (128409.2 892046.4, 128768.1…     1 #>  2       818.        25.0      101      362. (128553.4 891572.7, 128890.1…     2 #>  3      1242.        38.0      101      362. (128838.4 891220.8, 129145.3…     3 #>  4      1629.        49.8      101      362. (129198.3 890891.1, 129319.4…     4 #>  5      1962.        60.0      101      362. (129590.7 891044.8, 129463.9…     5 #>  6      2241.        68.5      101      362. (129732.4 891134.4, 129742 8…     6 #>  7      2487.        76.0      101      362. (129719.7 891083.8, 130016.4…     7 #>  8      2813.        86.0      101      362. (129907.8 891136.4, 130208.7…     8 #>  9      3260.        99.6      101      362. (130254.3 890553.2, 130336.7…     9 #> 10        77.8       11.1 24599575      362. (127993.3 892778.2, 128274.1…     1 #> # ℹ 2,265 more rows #> # ℹ 2 more variables: lengthm <dbl>, sinuosity <dbl>  plot(transects$geometry)"},{"path":"/articles/basic_use.html","id":"define-cross-section-points","dir":"Articles","previous_headings":"Example","what":"Define Cross section points","title":"Basic Use","text":"","code":"(pts = cross_section_pts(transects,                          dem = \"/vsicurl/https://prd-tnm.s3.amazonaws.com/StagedProducts/Elevation/1/TIFF/USGS_Seamless_DEM_1.vrt\")) #> Simple feature collection with 23416 features and 11 fields #> Geometry type: POINT #> Dimension:     XY #> Bounding box:  xmin: 77475.72 ymin: 890567.9 xmax: 130333.3 ymax: 939134.7 #> Projected CRS: NAD83 / Conus Albers #> # A tibble: 23,416 × 12 #>    hy_id cs_id pt_id     Z lengthm relative_distance ds_distance cs_measure #>    <dbl> <int> <int> <dbl>   <dbl>             <dbl>       <dbl>      <dbl> #>  1   101     1     1  42.2    362.               0          367.       11.2 #>  2   101     1     2  42.1    362.              32.9        367.       11.2 #>  3   101     1     3  42.5    362.              65.7        367.       11.2 #>  4   101     1     4  42.4    362.              98.6        367.       11.2 #>  5   101     1     5  40.2    362.             131.         367.       11.2 #>  6   101     1     6  40.2    362.             164.         367.       11.2 #>  7   101     1     7  36.2    362.             197.         367.       11.2 #>  8   101     1     8  39.9    362.             230.         367.       11.2 #>  9   101     1     9  39.7    362.             263.         367.       11.2 #> 10   101     1    10  40.5    362.             296.         367.       11.2 #> # ℹ 23,406 more rows #> # ℹ 4 more variables: cs_widths <dbl>, sinuosity <dbl>, points_per_cs <dbl>, #> #   geometry <POINT [m]>"},{"path":"/articles/basic_use.html","id":"classify-cross-section-points","dir":"Articles","previous_headings":"Example","what":"Classify Cross section points","title":"Basic Use","text":"","code":"(classified_pts = classify_points(pts)) #> Simple feature collection with 23416 features and 7 fields #> Geometry type: POINT #> Dimension:     XY #> Bounding box:  xmin: 77475.72 ymin: 890567.9 xmax: 130333.3 ymax: 939134.7 #> Projected CRS: NAD83 / Conus Albers #> # A tibble: 23,416 × 8 #>    hy_id cs_id pt_id     Z relative_distance cs_widths class      #>    <dbl> <int> <int> <dbl>             <dbl>     <dbl> <chr>      #>  1   101     1     1  42.2               0        362. left_bank  #>  2   101     1     2  42.2              32.9      362. left_bank  #>  3   101     1     3  42.3              65.7      362. left_bank  #>  4   101     1     4  41.7              98.6      362. channel    #>  5   101     1     5  40.9             131.       362. channel    #>  6   101     1     6  38.9             164.       362. channel    #>  7   101     1     7  36.2             197.       362. bottom     #>  8   101     1     8  38.6             230.       362. channel    #>  9   101     1     9  40.0             263.       362. right_bank #> 10   101     1    10  41.2             296.       362. right_bank #> # ℹ 23,406 more rows #> # ℹ 1 more variable: geometry <POINT [m]>"},{"path":"/articles/basic_use.html","id":"explore","dir":"Articles","previous_headings":"Example","what":"Explore!","title":"Basic Use","text":"","code":"library(ggplot2)  ggplot(data = filter(classified_pts, hy_id == 101) ) +    geom_line(aes(x = relative_distance, y = Z)) +    geom_point(aes(x = relative_distance, y = Z, color = class)) +    facet_wrap(~cs_id, scales = \"free\") +    theme_minimal() +    theme(legend.position = \"bottom\")"},{"path":"/articles/basic_use.html","id":"time-to-get-2275-transects-and-23416-classified-points","dir":"Articles","previous_headings":"Example","what":"Time to get 2275 transects and 23416 classified points …","title":"Basic Use","text":"","code":"system.time({   cs = net %>%    cut_cross_sections(id = \"comid\",                       cs_widths = pmax(50, net$bf_width * 7),                      num = 10) %>%    cross_section_pts(dem = '/vsicurl/https://prd-tnm.s3.amazonaws.com/StagedProducts/Elevation/1/TIFF/USGS_Seamless_DEM_1.vrt') %>%    classify_points() }) #> Smoothing #> Densifying #> Cutting #> Formating #> Warning: st_centroid assumes attributes are constant over geometries #>    user  system elapsed  #>  28.402   1.413  35.388"},{"path":"/articles/braided_cross_sections.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"NOAA OWP Braided Cross Section Reparation","text":"vignette breaks methods used within hydrofabric3D cut cross sections across complex braided river networks. following methods extend cross section cutting algorithms explained . begin testing set braided flowlines located Baton Rouge, LA. area complex set braids highlights need rectifying cross section linestrings better reflect natural world. Starting COMID 18717056, traverse upstream 30km get set 303 flowlines.   Now let’s add cross sections using algorithm described   created cross sections lines 10 transect lines per COMID/flowline geometry. problem section river braided want cross sections extend across multiple flowlines cases cross section line represents width across braided river sections, instead individual transect lines parallel braided flowlines. presents problem braided systems inherently complex irregular. want try extend cross section lines across flowlines given braid, first thing need way uniquely identifying braid flowlines within braid. accomplish , made use flowline /tonode topology relationships, implemented Depth First Search (DFS) graph traversal algorithm flowline network. DFS algorithm implemented way identify return set COMIDs make individual closed loop braid network.","code":"library(hydrofabric3D) library(dplyr) library(sf) library(ggplot2) library(nhdplusTools) # Heavily braided network in Baton Rouge, LA net <- nhdplusTools::navigate_network(start = 18717056, mode = \"UT\",  distance_km = 30)  flood_plain_sections = 5  net <-   net %>%   # https://agupubs.onlinelibrary.wiley.com/doi/full/10.1002/2013WR013916   dplyr::mutate(     bf_width = exp(0.700     + 0.365* log(totdasqkm)),     cs_width = flood_plain_sections * bf_width     ) %>%    dplyr::select(comid, divergence,bf_width, cs_width, lengthkm, totdasqkm, fromnode, tonode, terminalpa)  # set geometry name of network to \"geometry\" net <- nhdplusTools::rename_geometry(net, \"geometry\") transects <- hydrofabric3D::cut_cross_sections(   net        = net,   id         = \"comid\",   cs_widths  = 200,   num        = 10,   fix_braids = FALSE,   add        = TRUE   ) #> Warning: st_centroid assumes attributes are constant over geometries"},{"path":"/articles/braided_cross_sections.html","id":"locate-braided-flowlines","dir":"Articles","previous_headings":"","what":"Locate braided flowlines","title":"NOAA OWP Braided Cross Section Reparation","text":"find_braids() function can used identify assign braid_id flowline NHDPlus network dataset. input network data must include comid, fromnode, tonode, divergence attributes.  Now method identifying flowlines part braid unique ID braids network. Next, find cross section lines braided flowlines, work extending encompass entire width river crossing across rest braided flowlines. First want join transect lines sections rivers flowlines braid_id (flowlines part braid braid_id “no_braid”) seperate braided flowlines non braided flowlines:  join braided flowlines transects  gives us set cross sections braided flowlines:  can now iterate cross sections determine cross sections extended, order, distance.","code":"# add braid_id column to network braids <- hydrofabric3D::find_braids(     network     = net,      add         = TRUE,     nested      = TRUE   ) #> Warning in nhdplusTools::make_node_topology(network, div, add = TRUE): #> nhdplusTools make_node_topology is deprecated. Use hydroloom version.  #> Warning in nhdplusTools::make_node_topology(network, div, add = TRUE): #> nhdplusTools make_node_topology is deprecated. Use hydroloom version. # not braided flowlines not_braids <-  dplyr::filter(braids, braid_id == \"no_braid\")  # trim down network to just the braided parts, and add a comid count to separate out multibraids braids <- dplyr::filter(braids, braid_id != \"no_braid\")   # add connected component \"component_id\" column braids <- find_connected_components(braids) #> Warning in nhdplusTools::make_node_topology(network, div, add = TRUE): #> nhdplusTools make_node_topology is deprecated. Use hydroloom version. cross_sections <-    transects %>%   dplyr::filter(hy_id %in% braids$comid) %>%   dplyr::left_join(   sf::st_drop_geometry(     dplyr::select(       braids, comid, braid_id, is_multibraid     )   ),   by = c(\"hy_id\" = \"comid\")   ) %>%    dplyr::arrange(-totdasqkm)"},{"path":"/articles/braided_cross_sections.html","id":"identify-flowlines-to-extend-across","dir":"Articles","previous_headings":"","what":"Identify flowlines to extend across","title":"NOAA OWP Braided Cross Section Reparation","text":"braided COMID, want take cross sections lines COMID try extend cross sections cut across relevant braided flowlines area. image highlights “origin” COMID (blue), flowlines (red) selected transect algorithm try cut across generate extended cross section geometry. red flowlines set neighboring braided flowlines “origin” COMID (blue). transect extension algorithm takes transect linestrings blue COMID tries extend cross sections cut across neighboring flowlines (red)  see braided flowlines network, animation walks COMID braided flowlines (blue), shows remaining braided flowlines eligible cut across cross sections lines “origin” COMID (blue).  look individual COMID given braid, decide want extend cross sections COMID outward try cut across flowlines within braided system, now method selecting COMIDs candidates extended line cut across. didn’t come way distinguishing flowlines extended transect lines allowed cross , algorithm ultimately try extend transect indefinitely/attempt cut across flowlines network. wouldn’t make hydrologic computational sense.","code":""},{"path":"/articles/braided_cross_sections.html","id":"order-of-extensions","dir":"Articles","previous_headings":"","what":"Order of extensions","title":"NOAA OWP Braided Cross Section Reparation","text":"ever take transect line extend outward either direction, run possibility newly extended transect line now violate one fundemental properties cross sections: extended transect line now intersects another flowline outside braided area extended transect line now intersects another transect line extended transect line now intersects COMID/flowline Moreover, flowlines braided system given priority flowlines comes order transects extended. Transect lines middle braided system extended first likely produce representative transect line, want prioritize extending first. Determining middle flowline braided system challenge. cases, mainstem flowline middle flowline within braid, cases isn’t case. found solution relies number intersections flowlines transect line extended either direction. transect line, can count number intersections either side transect extend transect line far needed cross neighboring flowlines. Using technique classified cross section line 5 different catagories according relative position within braided system: intersection: transect line never intersects another flowline maximum extension directions Outer single: Transect line intersect zero flowlines one direction, exactly one flowline direction, case braid just 2 parts. Outer multiple: Transect line intersect zero flowlines one direction, one flowline direction Inner: Transect line middle braid. 2 scenarios, either even odd number parallel flowlines braid: Odd case: number intersections directions \\[ intersects\\_count_1 == intersects\\_count_2 \\] Even case: maximum number counted intersections minus one equals minimum number counted intersections \\[ \\max(intersects\\_count_1, intersects\\_count_2) - 1 == \\min(intersects\\_count_1, intersects\\_count_2) \\] - Transect line middle outer portion braid  relationships shown using simple set parallel lines meant represent flowlines braid. red line image set highlights specific line(s) fall given classification.  order get best set final transect lines, prioritize “inner” transect lines work extending ones first. plot highlights cross sections separated groups cross sections (red) line extended first, group (blue) extended first set cross sections extended processed   check done new extended transect lines make sure intersecting parts original network, cross section linestrings. identify cross sections linestrings intersect original, non braided network flowlines, remove cross sections data. first pass cross section extension algorithm, want make sure “inner” cross sections CHANGED, intersect cross section lines just updated. remove inner cross sections intersect cross sections, keeping rest unextended inner cross sections data. separate cross section data based whether cross section already changed/updated first pass line extension algorithm, . gives us 2 separate set cross sections: set inner cross section lines (extended checked violating intersections) extended violate intersections. rest unchanged cross sections need processed/extended (without intersecting transect lines first dataset processed “inner” cross sections)","code":""},{"path":"/articles/braided_cross_sections.html","id":"process-inner-cross-sections","dir":"Articles","previous_headings":"","what":"Process inner cross sections","title":"NOAA OWP Braided Cross Section Reparation","text":"run transect extension algorithm first group cross sections end set extended cross sections:","code":""},{"path":"/articles/braided_cross_sections.html","id":"process-other-cross-sections","dir":"Articles","previous_headings":"","what":"Process other cross sections","title":"NOAA OWP Braided Cross Section Reparation","text":"take remaining “” cross sections (cross sections braided flowlines part first set extended cross cross sections) begin extending remaining eligible cross sections.","code":""},{"path":"/articles/braided_cross_sections.html","id":"bring-it-all-back-together","dir":"Articles","previous_headings":"","what":"Bring it all back together","title":"NOAA OWP Braided Cross Section Reparation","text":"Now gone fixed cross section braided flowlines, can merge updated/extended cross section linestrings back rest original set cross section lines","code":""},{"path":"/articles/cross_section_generator.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"NOAA OWP Cross Section Generator","text":"need cut transects elevation along set lines (e.g. river road networks) fairly common task unsatisfying number shelf solutions. particular need OWP need cut cross sections across entire CONUS river network provide much needed information flood mapping hydrologic modeling tasks. document shows initial efforts towards scale. small sets cross sections tools developed Rich McDonald (e.g. nhdplusTools::get_xs_point) preferred.","code":""},{"path":"/articles/cross_section_generator.html","id":"prep-network","dir":"Articles","previous_headings":"","what":"Prep Network","title":"NOAA OWP Cross Section Generator","text":"loading Upper Tributary COMID 101. total 325 flowlines total length 942.3 km. also prescribe floodplain width computing estimated bank full width (literature based power-law) multiplying 5. assumes 2 parts left-bank, 1 part channel (bank full), 2 parts right-bank. important latter!","code":"flood_plain_sections = 5 network = linestring %>%    # https://agupubs.onlinelibrary.wiley.com/doi/full/10.1002/2013WR013916   mutate(bf_width = exp(0.700    + 0.365* log(totdasqkm)),          cs_width = flood_plain_sections * bf_width)"},{"path":"/articles/cross_section_generator.html","id":"algorithm-walk-through","dir":"Articles","previous_headings":"","what":"Algorithm Walk Through:","title":"NOAA OWP Cross Section Generator","text":"algorithm works generating set edges single line string, computing normal vector, transformed series afline transformations. illustrate lets start single flowline:","code":"linestring = filter(network, comid == 101)"},{"path":"/articles/cross_section_generator.html","id":"step-1-explode-linestring-into-edges","dir":"Articles","previous_headings":"Algorithm Walk Through:","what":"Step 1: Explode Linestring into edges:","title":"NOAA OWP Cross Section Generator","text":"","code":"# sf --> geos object  line <- as_geos_geometry(linestring)    # extract vertices  vertices <- wk_vertices(line)    # Use vertices to reconstruct line segments   edges <- as_geos_geometry(     wk_linestring(       vertices[c(1, rep(seq_along(vertices)[-c(1, length(vertices))], each = 2), length(vertices))],       feature_id = rep(seq_len(length(vertices) - 1), each = 2)     )   )"},{"path":"/articles/cross_section_generator.html","id":"step-2-define-edge-mid-and-end-point","dir":"Articles","previous_headings":"Algorithm Walk Through:","what":"Step 2: Define Edge Mid and End Point","title":"NOAA OWP Cross Section Generator","text":"next steps individual edge exploded linestring:","code":"# Starting with just the first edge edge  <-  edges[1] # Define a width of desired cross section width <-  linestring$cs_width  # find the midpoint midpoint <- geos_interpolate_normalized(edge, 0.5) # find the end point ep       <- geos_point_end(edge)"},{"path":"/articles/cross_section_generator.html","id":"step-3-define-cross-section-at-end-point","dir":"Articles","previous_headings":"Algorithm Walk Through:","what":"Step 3: Define Cross Section at end Point","title":"NOAA OWP Cross Section Generator","text":"generate cross section passes end point need steps","code":""},{"path":"/articles/cross_section_generator.html","id":"define-a-normal-edge","dir":"Articles","previous_headings":"Algorithm Walk Through: > Step 3: Define Cross Section at end Point","what":"Define a normal edge","title":"NOAA OWP Cross Section Generator","text":"3 transformations define normal edge: affine_translate: define coordinate offsets x, y direction negative value X Y coordinate edge midpoint affine_scale: apply X scale factor 1/length edge, Y scale factor 1/length edge Rotate new line 90 degrees","code":"normal_edge <- wk_transform(edge,                                  wk_affine_compose(             wk_affine_translate(dx = -geos_x(midpoint), dy = -geos_y(midpoint)),             wk_affine_scale(1 / geos_length(edge), 1 / geos_length(edge)),             wk_affine_rotate(90)   ))"},{"path":"/articles/cross_section_generator.html","id":"define-the-cross-sections","dir":"Articles","previous_headings":"Algorithm Walk Through: > Step 3: Define Cross Section at end Point","what":"Define the cross sections","title":"NOAA OWP Cross Section Generator","text":"2 transformations needed define cross section: affine_scale: apply X scale factor desired width, Y scale factor desired width affine_translate: define coordinate offsets x, y direction negative value X Y coordinate edge end point Lastly, CRS original line reassigned.","code":"cs = wk_set_crs(wk_transform(     normal_edge,     wk_affine_compose(       wk_affine_scale(width, width),       wk_affine_translate(geos_x(ep), geos_y(ep))     )), wk_crs(line))"},{"path":"/articles/cross_section_generator.html","id":"cut-a-full-flowline","dir":"Articles","previous_headings":"","what":"Cut a Full Flowline","title":"NOAA OWP Cross Section Generator","text":"Using logic, can write function generates series cross sections edge line string:  OK ’s pretty good! things don’t like. must enforce following two conditions: Condition 1: Cross sections cross Condition 2: single cross section cross given reach Predicates like st_intersect run end without wiping cross-sections intersect. , need implement logic enforce : Awesome! gained just fraction time ensuring set valid cross sections generated.","code":"# Make a function: cut_transect = function(edge, width){        midpoint <- geos_interpolate_normalized(edge, 0.5)   ep       <- geos_point_end(edge)      normale_edge <- wk_transform(edge,                                    wk_affine_compose(               wk_affine_translate(dx = -geos_x(midpoint), dy = -geos_y(midpoint)),               wk_affine_scale(1 / geos_length(edge), 1 / geos_length(edge)),               wk_affine_rotate(90)))        wk_set_crs(wk_transform(       normale_edge,       wk_affine_compose(         wk_affine_scale(width, width),         wk_affine_translate(geos_x(ep), geos_y(ep))       )     ), wk_crs(edge)) }  system.time({   all = vec_c(!!!Map(cut_transect, edges, width = linestring$cs_width)) }) ##    user  system elapsed  ##   0.111   0.005   0.152 get_transects = function(edges, line, width){      if(length(width) != length(edges)){     width = rep(width[1], length(edges))   }      transects <- geos_empty()      for(i in 1:length(edges)){          tran = cut_transect(edges[i], width[i])          # If a MULTIPOINT, then it crosses more the once     if(geos_type(geos_intersection(tran, line)) == \"point\") {       # Ensure that there are no intersections with previously computed cross sections         if (!any(geos_intersects(tran, transects))) {           transects <-  vec_c(transects, tran)         }       }   }    transects[!geos_is_empty(transects)]  }  system.time({  transects =  get_transects(edges, line, width = 250) }) ##    user  system elapsed  ##   0.230   0.013   0.353"},{"path":"/articles/cross_section_generator.html","id":"flow-network","dir":"Articles","previous_headings":"Cut a Full Flowline","what":"Flow Network","title":"NOAA OWP Cross Section Generator","text":"OK, gone single edge, full flowline. Now - full network! , requires looping flowlines. Additionally add new items: num argument allows user restrict number cross sections desired per flowline. id argument allows user specify identifier column input. provided assigned “hy_id” output. prescribed, 1:n() index added. outputs also 1:n() cs_id describing ordered set cross sections 1 upstream n downstream. Lastly, final pass made remove cross sections intersect cross section different flowline.","code":"cut_cross_sections = function(net, id = NULL, widths = NULL, num = NULL){      ll = list()      if(length(widths) != nrow(net)){     widths = rep(widths[1], nrow(net))   }    for(j in 1:nrow(net)){         line <- as_geos_geometry(net[j,])         vertices <- wk_vertices(line)          edges <- as_geos_geometry(       wk_linestring(         vertices[c(1, rep(seq_along(vertices)[-c(1, length(vertices))], each = 2), length(vertices))],         feature_id = rep(seq_len(length(vertices) - 1), each = 2)       )     )         if(!is.null(num)){       edges = edges[as.integer(seq.int(1, length(edges), length.out = num))]     }      ll[[j]] = get_transects(edges, line, widths[j])   }    ids_length = lengths(ll)   ll = st_as_sf(Reduce(c,ll))      if(!is.null(id)){     ll$hy_id = rep(net[[id]], times = ids_length)   } else {      ll$hy_id = rep(1:nrow(net), times = ids_length)   }      ll[lengths(st_intersects(ll)) == 1, ] %>%      group_by(hy_id) %>%      mutate(cs_id = 1:n()) %>%      ungroup()    }  system.time({   oo = cut_cross_sections(net = network,                            id = \"comid\",                            widths = network$cs_width,                           num = 10) }) ##    user  system elapsed  ##  10.364   0.433  11.889"},{"path":"/articles/cross_section_generator.html","id":"transects-to-3d-channel","dir":"Articles","previous_headings":"Cut a Full Flowline","what":"Transects to 3D channel","title":"NOAA OWP Cross Section Generator","text":"turn extracted transect set “3D” cross sections, need define set number points sample along line, use extract elevation DEM. , use VRT file 10m 3DEP elevation data produced National Map support 3DEP team.","code":"library(terra) points_per_cs = 35 elev_url = \"/vsicurl/https://prd-tnm.s3.amazonaws.com/StagedProducts/Elevation/13/TIFF/USGS_Seamless_DEM_13.vrt\"  extract_pt_val = function(rast, pts){ extract(rast, project(vect(pts), crs(rast)))[,2] }  system.time({   cs_pts =        st_set_geometry(oo, st_line_sample(oo, points_per_cs)) %>%        st_cast(\"POINT\") %>%       st_transform(st_crs(rast(elev_url))) %>%        mutate(Z   = extract_pt_val(rast(elev_url), .)) %>%        group_by(hy_id, cs_id) %>%        mutate(pt_id = 1:n()) %>%        ungroup() }) ##    user  system elapsed  ##   9.671   0.921  34.639"},{"path":"/articles/cross_section_generator.html","id":"reach-addressing","dir":"Articles","previous_headings":"","what":"Reach Addressing","title":"NOAA OWP Cross Section Generator","text":"key hydrologic locations linear reference describes percentage along reach location sits. reference center cross section, can use flowline indexing tools nhdplusTools:","code":"system.time({   # Find middle point of each cross section   tmp = cs_pts %>%      group_by(hy_id, cs_id) %>%      arrange(pt_id) %>%      slice(ceiling(n()/2))  %>%      ungroup() %>%      st_transform(5070)    # Add the needed information to our network object, and fine flowline index   xx = left_join(network,                   get_vaa(c(\"tomeas\", \"frommeas\", 'reachcode'), updated_network = TRUE),                   by = c(\"comid\")) %>%       get_flowline_index(tmp) %>%       mutate(cs_id = tmp$cs_id[id], id = NULL) %>%       rename(hy_id = COMID)      # add new information of cs_pts and rearrange columns   cs_pts = left_join(cs_pts, xx, by = c(\"hy_id\", \"cs_id\")) %>%      select(hy_id, cs_id, pt_id, everything()) })    head(cs_pts)"},{"path":"/articles/cross_section_generator.html","id":"channel-classifiction","dir":"Articles","previous_headings":"","what":"Channel Classifiction","title":"NOAA OWP Cross Section Generator","text":"OK now cut cross sections along network, sampled extracted depths, addressed hydrologic network! Now, want assign classification point marking “right_bank”, “in_channel” “left_bank”.","code":"assign_class = function(Z, ratio = 1/5){       # The change in elevation across the cross section   dY = c(diff(Z), 0)   # devise a threshold for each section based on the prescribed ratio   thres = ratio * length(Z)   # Assume the left side is 2* threshold   la = 2*thres   # Assume the channel is the left edge plus one part.   ca = la:(thres + la)      # Assume the channel sits within the middle part + or minus a part   mid_sec = Z[(2*thres):(length(Z)-2*thres)+1]   mid = floor(median(which(Z == min(mid_sec) )))      if(mid < 2*thres | mid > 2 * thres){     mid = min(mid_sec)      mid = floor(median(which(mid_sec == mid))) + 2*thres   }    lb = which.min(dY[(mid-thres):mid]) + (mid-thres) - 2      rb = which.max(dY[(mid):(mid+thres)])  + mid + 1      class = rep(\"in_channel\", length(Z))   class[1:lb] = \"left_bank\"   class[rb:length(Z)] = \"right_bank\"      if(length(class) != length(Z) |  dim(table(class)) != 3){     class = c(rep(\"left_bank\", 2*thres),                rep('in_channel', thres),                rep(\"right_bank\", 2*thres))   }      class }  system.time({   cs_pts = cs_pts %>%      group_by(hy_id, cs_id) %>%     mutate(class = assign_class(Z, ratio = 1/flood_plain_sections)) %>%      ungroup() })  mapview::mapview(network)"},{"path":"/articles/cross_section_generator.html","id":"channel-bottom-alignment-and-bank-smoothing","dir":"Articles","previous_headings":"","what":"Channel bottom alignment and bank smoothing","title":"NOAA OWP Cross Section Generator","text":"Lastly, successful routing implementation, need ensure bottom cross section lower equal one upstream. traverse network making sure condition met, , cases isn’t, lower channel portion cross section make :","code":""},{"path":"/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Mike Johnson. Author, maintainer. Angus Watters. Author.","code":""},{"path":"/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Johnson M, Watters (2023). hydrofabric3D: hydrofabric3D. R package version 0.0.1.","code":"@Manual{,   title = {hydrofabric3D: hydrofabric3D},   author = {Mike Johnson and Angus Watters},   year = {2023},   note = {R package version 0.0.1}, }"},{"path":"/index.html","id":"hydrofabric3d","dir":"","previous_headings":"","what":"3D Hydrofabric Generation","title":"3D Hydrofabric Generation","text":"goal hydrofabric3D generate DEM-based cross sections hydrographic networks.","code":""},{"path":"/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"3D Hydrofabric Generation","text":"can install development version hydrofabric3D GitHub :","code":"# install.packages(\"devtools\") devtools::install_github(\"mikejohnson51/hydrofabric3D\")"},{"path":"/reference/classify_points.html","id":null,"dir":"Reference","previous_headings":"","what":"Classify Cross Section Points — classify_points","title":"Classify Cross Section Points — classify_points","text":"Classify Cross Section Points","code":""},{"path":"/reference/classify_points.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Classify Cross Section Points — classify_points","text":"","code":"classify_points(cs_pts)"},{"path":"/reference/classify_points.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Classify Cross Section Points — classify_points","text":"cs_pts CS points","code":""},{"path":"/reference/classify_points.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Classify Cross Section Points — classify_points","text":"sf object","code":""},{"path":"/reference/cross_section_pts.html","id":null,"dir":"Reference","previous_headings":"","what":"Get Points across transects with elevation values — cross_section_pts","title":"Get Points across transects with elevation values — cross_section_pts","text":"Get Points across transects elevation values","code":""},{"path":"/reference/cross_section_pts.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get Points across transects with elevation values — cross_section_pts","text":"","code":"cross_section_pts(   cs,   points_per_cs = NULL,   min_pts_per_cs = 10,   dem =     \"/vsicurl/https://prd-tnm.s3.amazonaws.com/StagedProducts/Elevation/13/TIFF/USGS_Seamless_DEM_13.vrt\" )"},{"path":"/reference/cross_section_pts.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Get Points across transects with elevation values — cross_section_pts","text":"cs Hydrographic LINESTRING Network points_per_cs desired number points per CS. NULL, approximently 1 per grid cell resultion DEM selected. min_pts_per_cs Minimun number points per cross section required. dem DEM extract data ","code":""},{"path":"/reference/cross_section_pts.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Get Points across transects with elevation values — cross_section_pts","text":"sf object","code":""},{"path":"/reference/cut_cross_sections.html","id":null,"dir":"Reference","previous_headings":"","what":"Generate Cross Sections Across Hydrographic Network — cut_cross_sections","title":"Generate Cross Sections Across Hydrographic Network — cut_cross_sections","text":"Generate Cross Sections Across Hydrographic Network","code":""},{"path":"/reference/cut_cross_sections.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Generate Cross Sections Across Hydrographic Network — cut_cross_sections","text":"","code":"cut_cross_sections(   net,   id = NULL,   cs_widths = 100,   num = 10,   smooth = TRUE,   densify = 2,   rm_self_intersect = TRUE,   fix_braids = FALSE,   terminal_id = NULL,   braid_threshold = NULL,   version = 2,   braid_method = \"comid\",   precision = 1,   add = FALSE )"},{"path":"/reference/cut_cross_sections.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Generate Cross Sections Across Hydrographic Network — cut_cross_sections","text":"net Hydrographic LINESTRING Network id Unique Identifier net cs_widths Bankfull Widths (length cross sections net element) num Number transects per Net element smooth logical, whether smooth linestring geometries . Default TRUE. densify numeric, many times points added linestrings. Default 2. rm_self_intersect logical, whether remove self intersecting transect linestrings fix_braids logical, whether fix braided transect lines . TRUE, linestrings part braided network augmented. Default FALSE. terminal_id character, column name containing unique identifier, delineating separate networks 'net' dataset. Default NULL best effort determine connected components network try create 'component_id' column 'net' braid_threshold numeric value, value total length flowlines braid. braids total flowline lengths less equal threshold considered function (.e. determines maximum braid size fix_braid_transects() operate ). Default NULL, attempt fix braid transects data version integer, version number braid algorithm use, either 1 2. Default 2. braid_method method determine geometries cut. Options \"comid\", \"component\", \"neighbor\". Default \"comid\" precision int, distance meters. applicable fix_braids = TRUE. number meters approximate final cross section linestring length. Increasing value decrease runtime cross section extension algorithm. Value must greater 0. Default 1 add logical indicating whether add original 'net' data outputted transect lines. Default FALSE.","code":""},{"path":"/reference/cut_cross_sections.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Generate Cross Sections Across Hydrographic Network — cut_cross_sections","text":"sf object","code":""},{"path":"/reference/cut_transect.html","id":null,"dir":"Reference","previous_headings":"","what":"Generate a Perpendicular Linestring of a Given Width — cut_transect","title":"Generate a Perpendicular Linestring of a Given Width — cut_transect","text":"Generate Perpendicular Linestring Given Width","code":""},{"path":"/reference/cut_transect.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Generate a Perpendicular Linestring of a Given Width — cut_transect","text":"","code":"cut_transect(edge, width)"},{"path":"/reference/cut_transect.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Generate a Perpendicular Linestring of a Given Width — cut_transect","text":"edge LINESRTING width Length Perpendicular LINESTRING","code":""},{"path":"/reference/cut_transect.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Generate a Perpendicular Linestring of a Given Width — cut_transect","text":"GEOS object","code":""},{"path":"/reference/find_braids.html","id":null,"dir":"Reference","previous_headings":"","what":"Find braids and add to a dataframe/sf dataframe — find_braids","title":"Find braids and add to a dataframe/sf dataframe — find_braids","text":"Find uniquely identify braids network flowlines, given dataframe containing comid, fromnode, tonode divergence columns. 'find_braids()\" identifies braids cycles graph representation river network.","code":""},{"path":"/reference/find_braids.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Find braids and add to a dataframe/sf dataframe — find_braids","text":"","code":"find_braids(   network,   terminal_id = NULL,   add = FALSE,   nested = TRUE,   version = 2,   verbose = FALSE )"},{"path":"/reference/find_braids.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Find braids and add to a dataframe/sf dataframe — find_braids","text":"network network object representing river network. terminal_id character, column name containing unique identifier, delineating separate networks 'network' dataset. Default NULL use 'find_connected_components()' determine connected components graph try create 'component_id' column 'network' add Logical indicating whether add braid information original network data. nested Logical indicating whether output dataframe nested, COMID list braids part . TRUE (Default), braid_id column may contain multiple braid IDs given COMID. FALSE, may duplicate COMIDs single COMID part multiple braids (braid_id) version integer, version number multibraid classification grouping algorithm, must either 1 2. Default 2. verbose Logical indicating whether display verbose messages braid detection process.","code":""},{"path":"/reference/find_braids.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Find braids and add to a dataframe/sf dataframe — find_braids","text":"dataframe sf dataframe added braid_id","code":""},{"path":"/reference/find_braids.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Find braids and add to a dataframe/sf dataframe — find_braids","text":"","code":"if (FALSE) { net <- nhdplusTools::navigate_network(  start       = 101,  mode        = \"UT\",  distance_km = 100  )    # drop most of the columns in the network dataset net <- dplyr::select(net, comid, divergence, totdasqkm, fromnode, tonode, terminalpa)  # get a dataframe of COMIDs and braid IDs braids <- find_braids(network = net, add = FALSE)  # add braid_id column to original dataset braid_df = find_braids(network   = net,                        add       = TRUE,                        nested    = TRUE,                        )  # returnal original data with each braid_id represented # by its individual COMIDs (may contain duplicate COMIDs) nested_braids = find_braids(network   = net,                        add       = TRUE,                        nested    = FALSE                        ) # if a column exists that uniquely identifies different contiguous networks, # the column name can be given to 'terminal_id' to delianiate seperate networks within 'net' sep_braids = find_braids(network     = net,                          terminal_id = \"terminalpa\",                          add         = TRUE,                          nested      = FALSE                        ) }"},{"path":"/reference/find_connected_components.html","id":null,"dir":"Reference","previous_headings":"","what":"Find the connected components in a NHDPlus flowlines Network — find_connected_components","title":"Find the connected components in a NHDPlus flowlines Network — find_connected_components","text":"Determine many different, unconnected/seperate sets flowlines within set NHDPlus flowlines. input 'network' dataset must contain comid, tonode, fromnode, (optionally) divergence terminalpa attributes. Used internally within 'get_braid_list' 'find_braids()' function make sure connected set flowlines addressed braids searched seperated component.","code":""},{"path":"/reference/find_connected_components.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Find the connected components in a NHDPlus flowlines Network — find_connected_components","text":"","code":"find_connected_components(   network,   add = TRUE,   arbitrary = TRUE,   verbose = FALSE )"},{"path":"/reference/find_connected_components.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Find the connected components in a NHDPlus flowlines Network — find_connected_components","text":"network data.frame sf object comid, tonode, fromnode, (optionally) divergence terminalpa attributes. \"tocomid\" column exists, recommended remove beforehand add logical, whether add component_id original dataset. TRUE (default) original dataset returned additional component_id column, indicating set connected components comid belongs . FALSE, dataframe COMID component_id returned arbitrary logical, whether use arbitrary numbering components use starting COMID component_id. TRUE (default) components given component ID 1 number components, otherwise (FALSE) arbitrary COMID used component_id flag connected components verbose logical print status updates, TRUE, messages print. Default FALSE.","code":""},{"path":"/reference/find_connected_components.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Find the connected components in a NHDPlus flowlines Network — find_connected_components","text":"original dataframe added 'component_id' column (add = TRUE) new dataframe \"comid\" \"component_id\" columns (add = FALSE)","code":""},{"path":"/reference/fix_braid_transects.html","id":null,"dir":"Reference","previous_headings":"","what":"Fix transects found on braided river sections — fix_braid_transects","title":"Fix transects found on braided river sections — fix_braid_transects","text":"Fix transects found braided river sections","code":""},{"path":"/reference/fix_braid_transects.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Fix transects found on braided river sections — fix_braid_transects","text":"","code":"fix_braid_transects(   net,   transect_lines,   terminal_id = NULL,   braid_threshold = NULL,   version = 2,   method = \"comid\",   precision = 1,   rm_intersects = TRUE )"},{"path":"/reference/fix_braid_transects.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Fix transects found on braided river sections — fix_braid_transects","text":"net sf object NHDplusv2 data transect_lines sf linestring dataframe, containing cross sections flowlines 'net' output \"cut_cross_sections2()\" function terminal_id character, column name containing unique identifier, delineating seperate networks 'network' dataset. Default NULL use 'find_connected_components()' determine connected components graph try create 'component_id' column 'network' braid_threshold numeric value, value total length flowlines braid. braids total flowline lengths less equal threshold considered function (.e. determines maximum braid size fix_braid_transects() operate ). Default NULL, attempt fix braid transects data version integer, version number braid algorithm use, either 1 2. Default 2. method method determine geometries cut. Options \"comid\", \"component\", \"neighbor\". Default \"comid\" precision int, distance meters approximate final cross section linestring length. Value must greater 0. Default 1 rm_intersects logical, whether remove transect linestrings intersect parts network ('net'). Default TRUE remove intersecting linestrings.","code":""},{"path":"/reference/fix_braid_transects.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Fix transects found on braided river sections — fix_braid_transects","text":"sf object transect linestrings","code":""},{"path":"/reference/get_braid_list.html","id":null,"dir":"Reference","previous_headings":"","what":"Create a list of braid IDs containing COMIDs in each braid — get_braid_list","title":"Create a list of braid IDs containing COMIDs in each braid — get_braid_list","text":"Find uniquely identify braids network flowlines, given dataframe containing comid, fromnode, tonode divergence columns. 'find_braids()\" identifies braids cycles graph representation river network.","code":""},{"path":"/reference/get_braid_list.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create a list of braid IDs containing COMIDs in each braid — get_braid_list","text":"","code":"get_braid_list(network, terminal_id = NULL, verbose = FALSE)"},{"path":"/reference/get_braid_list.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create a list of braid IDs containing COMIDs in each braid — get_braid_list","text":"network network object representing river network. terminal_id character, column name containing unique identifier, delineating seperate networks 'network' dataset. Default NULL use 'find_connected_components()' determine connected components graph try create 'component_id' column 'network' verbose Logical indicating whether display verbose messages braid detection process.","code":""},{"path":"/reference/get_braid_list.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create a list of braid IDs containing COMIDs in each braid — get_braid_list","text":"list braid IDs COMIDs within braid","code":""},{"path":"/reference/get_braid_list.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Create a list of braid IDs containing COMIDs in each braid — get_braid_list","text":"","code":"if (FALSE) { net <- nhdplusTools::navigate_network(  start       = 101,  mode        = \"UT\",  distance_km = 100  )   net <- dplyr::select(net, comid, divergence, totdasqkm, fromnode, tonode, terminalpa)  # get a dataframe of COMIDs and braid IDs braids <- get_braid_list(network = net) }"},{"path":"/reference/get_transects.html","id":null,"dir":"Reference","previous_headings":"","what":"Generate Multiple cross section along a linestring — get_transects","title":"Generate Multiple cross section along a linestring — get_transects","text":"Generate Multiple cross section along linestring","code":""},{"path":"/reference/get_transects.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Generate Multiple cross section along a linestring — get_transects","text":"","code":"get_transects(line, bf_width, n)"},{"path":"/reference/get_transects.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Generate Multiple cross section along a linestring — get_transects","text":"line sf linestring geos_geometry, original line element bf_width Bankfull Width (length cross section) n number cross sections","code":""},{"path":"/reference/get_transects.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Generate Multiple cross section along a linestring — get_transects","text":"sf dataframe 'n' evenly spaced transect lines cs_measures cross section geometry","code":""},{"path":"/reference/is_braided.html","id":null,"dir":"Reference","previous_headings":"","what":"Detect whether a braid exists in a NHDPlus flowlines Network\nCheck if if a NHDPlus network dataset contains any braids. If multiple discontinuous networks are within the 'network' data, a 'terminal_id' can be be provided to uniquely check each network for braids. If no terminal_id is given, the function will try to infer the distinct networks and then check for braids in each component (using find_connected_components()). — is_braided","title":"Detect whether a braid exists in a NHDPlus flowlines Network\nCheck if if a NHDPlus network dataset contains any braids. If multiple discontinuous networks are within the 'network' data, a 'terminal_id' can be be provided to uniquely check each network for braids. If no terminal_id is given, the function will try to infer the distinct networks and then check for braids in each component (using find_connected_components()). — is_braided","text":"Detect whether braid exists NHDPlus flowlines Network Check NHDPlus network dataset contains braids. multiple discontinuous networks within 'network' data, 'terminal_id' can provided uniquely check network braids. terminal_id given, function try infer distinct networks check braids component (using find_connected_components()).","code":""},{"path":"/reference/is_braided.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Detect whether a braid exists in a NHDPlus flowlines Network\nCheck if if a NHDPlus network dataset contains any braids. If multiple discontinuous networks are within the 'network' data, a 'terminal_id' can be be provided to uniquely check each network for braids. If no terminal_id is given, the function will try to infer the distinct networks and then check for braids in each component (using find_connected_components()). — is_braided","text":"","code":"is_braided(network, terminal_id = NULL, recycle = FALSE, verbose = FALSE)"},{"path":"/reference/is_braided.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Detect whether a braid exists in a NHDPlus flowlines Network\nCheck if if a NHDPlus network dataset contains any braids. If multiple discontinuous networks are within the 'network' data, a 'terminal_id' can be be provided to uniquely check each network for braids. If no terminal_id is given, the function will try to infer the distinct networks and then check for braids in each component (using find_connected_components()). — is_braided","text":"network data.frame comid, tonode, fromnode, divergence (optionally)  terminalpa attributes. terminal_id character, column name containing unique identifier, delineating separate networks 'network' dataset. Default NULL use 'find_connected_components()' determine connected components graph try create 'component_id' column 'network' recycle logical, whether return logical vector recycled length number unique networks (disconnected networks/outlets/terminalpa). FALSE (default), function returns TRUE networks contain braid. Otherwise, TRUE, function attempts distinguish different/separate network components returns logical vector length number connected components network.'terminal_id' given, return logical vector use 'terminal_id' column name vector, 'terminal_id' NULL, arbitrary COMID used uniquely identify distinct port network arbitrary COMIDs used name logical vector elements. verbose logical print status updates, TRUE, messages print. Default FALSE.","code":""},{"path":"/reference/is_braided.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Detect whether a braid exists in a NHDPlus flowlines Network\nCheck if if a NHDPlus network dataset contains any braids. If multiple discontinuous networks are within the 'network' data, a 'terminal_id' can be be provided to uniquely check each network for braids. If no terminal_id is given, the function will try to infer the distinct networks and then check for braids in each component (using find_connected_components()). — is_braided","text":"logical, TRUE, atleast one braid detected network, FALSE braids found. multiple components found terminal_id column given, unique network checked braiding (recycles length unique \"terminal_id\")","code":""},{"path":"/reference/linestring.html","id":null,"dir":"Reference","previous_headings":"","what":"Tester — linestring","title":"Tester — linestring","text":"Tester","code":""},{"path":"/reference/linestring.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Tester — linestring","text":"","code":"linestring"},{"path":"/reference/linestring.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Tester — linestring","text":"object class sf (inherits tbl_df, tbl, data.frame) 325 rows 5 columns.","code":""},{"path":"/reference/unique_braids.html","id":null,"dir":"Reference","previous_headings":"","what":"Create a list of braid IDs containing COMIDs in each braid for a single continguous network — unique_braids","title":"Create a list of braid IDs containing COMIDs in each braid for a single continguous network — unique_braids","text":"Find uniquely identify braids network flowlines, given dataframe containing comid, fromnode, tonode divergence columns. 'find_braids()\" identifies braids cycles graph representation river network. Internal function use 'get_braid_list()'","code":""},{"path":"/reference/unique_braids.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create a list of braid IDs containing COMIDs in each braid for a single continguous network — unique_braids","text":"","code":"unique_braids(network, start = NULL, verbose = FALSE)"},{"path":"/reference/unique_braids.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create a list of braid IDs containing COMIDs in each braid for a single continguous network — unique_braids","text":"network network object representing river network. start Optional argument specifying starting point braid detection. verbose Logical indicating whether display verbose messages braid detection process.","code":""},{"path":"/reference/unique_braids.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create a list of braid IDs containing COMIDs in each braid for a single continguous network — unique_braids","text":"list braid IDs COMIDs within braid","code":""},{"path":"/reference/unnpack_braids.html","id":null,"dir":"Reference","previous_headings":"","what":"Utility function that takes the output from 'find_braids(nested = TRUE)' and unpacks/unnests braid_id column — unnpack_braids","title":"Utility function that takes the output from 'find_braids(nested = TRUE)' and unpacks/unnests braid_id column — unnpack_braids","text":"Unnests comma seperated braid_id column individual rows braid ID/comid pairing. function unnest nested braid_ids column output calling 'find_braids()' 'nested = TRUE', essentially giving output running 'nested = FALSE'.","code":""},{"path":"/reference/unnpack_braids.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Utility function that takes the output from 'find_braids(nested = TRUE)' and unpacks/unnests braid_id column — unnpack_braids","text":"","code":"unnpack_braids(braids, into_list = FALSE)"},{"path":"/reference/unnpack_braids.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Utility function that takes the output from 'find_braids(nested = TRUE)' and unpacks/unnests braid_id column — unnpack_braids","text":"braids dataframe sf dataframe containing \"comid\" \"braid_id\" column into_list logical, TRUE, unpacked braid_ids corresponding comids returned list. Default FALSE","code":""},{"path":"/reference/unnpack_braids.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Utility function that takes the output from 'find_braids(nested = TRUE)' and unpacks/unnests braid_id column — unnpack_braids","text":"dataframe list","code":""},{"path":"/reference/unnpack_braids.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Utility function that takes the output from 'find_braids(nested = TRUE)' and unpacks/unnests braid_id column — unnpack_braids","text":"","code":"if (FALSE) { # get a NHDPlus flowlines network net <- nhdplusTools::navigate_network(start = 101, mode = \"UT\", distance_km = 100)  # Drop some columns for clarity net <- dplyr::select(net, comid, divergence, fromnode, tonode)  # locate braids in the network and specify nested braid_id return braids <- find_braids(net, add = TRUE, nested = TRUE)  # unnest the nested braid_id column (explode the list column into individual rows) unpacked <- unnpack_braids(braids) }"}]
