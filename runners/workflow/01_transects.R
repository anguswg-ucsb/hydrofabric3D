# Generate the flowlines layer for the final cross_sections_<VPU>.gpkg for each VPU
source("runners/workflow/config.R")

library(terrainSliceR)
library(dplyr)
library(sf)

# name of S3 bucket
s3_bucket <- "s3://lynker-spatial/"

# transect bucket prefix
transects_prefix <- glue::glue("{s3_bucket}v20/3D/transects/")

# paths to nextgen datasets and model attribute parquet files
nextgen_files <- list.files(nextgen_dir, full.names = FALSE)
model_attr_files <- list.files(model_attr_dir, full.names = FALSE)

# Full paths to nextgen datasets
nextgen_paths <- glue::glue("{nextgen_dir}{nextgen_files}")

# Full paths to nextgen datasets\
model_attr_paths <- glue::glue("{model_attr_dir}{model_attr_files}")

# string to fill in "cs_source" column in output datasets
net_source <- "terrainSliceR"

# ensure the files are in the same order and matched up by VPU
path_df <- align_files_by_vpu(
                x    = nextgen_files,
                y    = model_attr_files,
                base = base_dir
                )

for(i in 1:nrow(path_df)) {
  # i = 4
  # nextgen file and full path
  nextgen_file <- path_df$x[i]
  nextgen_path <- glue::glue("{nextgen_dir}{nextgen_file}")
  
  # model attributes file and full path
  model_attr_file <- path_df$y[i]
  model_attr_path <- glue::glue("{model_attr_dir}{model_attr_file}")

  logger::log_info("\n\nCreating VPU {path_df$vpu[i]} transects:\n - flowpaths: '{nextgen_file}'\n - model attributes: '{model_attr_file}'")
  
  # read in nextgen data
  flines <- sf::read_sf(nextgen_path, layer = "flowpaths")

  #  model attributes
  model_attrs <- arrow::read_parquet(model_attr_path)

  # join flowlines with model atttributes
  flines <- dplyr::left_join(
    flines,
    dplyr::select(
      model_attrs,
      id, eTW
    ),
    by = "id"
  )
  
  # calculate bankfull width
  flines <-
    flines %>%
    dplyr::mutate(
      bf_width = 11 * eTW
    ) %>%
    dplyr::mutate( # if there are any NAs, use exp(0.700    + 0.365* log(tot_drainage_areasqkm)) equation to calculate bf_width
      bf_width = dplyr::case_when(
        is.na(bf_width) ~ exp(0.700    + 0.365* log(tot_drainage_areasqkm)),
        TRUE            ~ bf_width
      )
    ) %>%
    dplyr::select(
      hy_id = id,
      lengthkm,
      tot_drainage_areasqkm,
      bf_width,
      geometry = geom
    )
  
  # flines$bf_width <- ifelse(is.na(flines$bf_width),  exp(0.700    + 0.365* log(flines$tot_drainage_areasqkm)), flines$bf_width)

  time1 <- Sys.time()
 # system.time({
    # create transect lines
    transects <- terrainSliceR::cut_cross_sections(
      net               = flines,                        # flowlines network
      id                = "hy_id",                       # Unique feature ID
      cs_widths         = pmax(50, flines$bf_width), # cross section width of each "id" linestring ("hy_id")
      num               = 10,                            # number of cross sections per "id" linestring ("hy_id")
      smooth            = TRUE,                          # smooth lines
      densify           = 3,                             # densify linestring points
      rm_self_intersect = TRUE,                          # remove self intersecting transects
      fix_braids        = FALSE,                         # whether to fix braided flowlines or not
      #### Arguments used for when fix_braids = TRUE
      # terminal_id       = NULL,
      # braid_threshold   = NULL,
      # version           = 2,
      # braid_method      = "comid",
      # precision         = 1,
      add               = TRUE                           # whether to add back the original data
    )
  # })
    
  time2 <- Sys.time()
  time_diff <- round(as.numeric(time2 - time1 ), 2)
  
  logger::log_info("\n\n -> Transects processed in {time_diff}")
  
  # name of file and path to save transects gpkg too
  out_file <- glue::glue("nextgen_{path_df$vpu[i]}_transects.gpkg")
  out_path <- glue::glue('{transects_dir}{out_file}')
  
  logger::log_info("\n\nSaving transects to:\n - filepath: '{out_path}'")
  
  # add cs_source column and keep just the desired columns to save and upload to S3
  transects <-
    transects %>%
    dplyr::mutate(
      cs_source = net_source
    ) %>%
    dplyr::select(
      hy_id,
      cs_source,
      cs_id,
      cs_measure,
      cs_lengthm = cs_widths,
      geometry
    )

  # save flowlines to out_path (lynker-spatial/01_transects/transects_<VPU num>.gpkg)
  sf::write_sf(
    transects,
    out_path
  )
  
  # sf::write_sf(
  #   dplyr::select(
  #     dplyr::mutate(transects,
  #                   cs_source = net_source
  #     ),
  #     hy_id, cs_source, cs_id, cs_measure,
  #     cs_lengthm = cs_widths,
  #     geometry
  #   ),
  #   out_path
  # )
  
  # command to copy transects geopackage to S3
  if (!is.null(aws_profile)) {
    copy_to_s3 <- glue::glue("aws s3 cp {out_path} {transects_prefix}{out_file} --profile {aws_profile}")
  } else {
    copy_to_s3 <- glue::glue("aws s3 cp {out_path} {transects_prefix}{out_file}")
  }
  
  logger::log_info("\n\nCopy VPU {path_df$vpu[i]} transects to S3:\n - S3 copy command:\n'{copy_to_s3}'\n==========================")
  system(copy_to_s3, intern = TRUE)
}


# list.files("/Users/anguswatters/Desktop/lynker-spatial/01_flowlines/")
# 
# for (i in 1:length(nextgen_paths)) {
#   i = 8
#   # sf::st_layers(nextgen_paths[i])
#   logger::log_info("Processing flowlines: {nextgen_files[i]}")
#   
#   #  moddel attributes
#   model_attrs <- arrow::read_parquet("/Users/anguswatters/Desktop/lynker-spatial/model_attributes/nextgen_3D_12.parquet")
#   # arrow::read_parquet()
#   model_attr_paths[i]
#   glue::glue("{model_attr_paths[i]}")
#   # read in nextgen data
#   flines <- sf::read_sf(nextgen_paths[i], layer = "flowpaths")
#   
#   # join flowlines with model atttributes
#   flines <- dplyr::left_join(
#                   flines,
#                   dplyr::select(
#                     model_attrs,
#                     id, eTW
#                     ),
#                   by = "id"
#                   )
#   # calculate bankful width 
#   flines <-
#     flines %>% 
#     # dplyr::mutate(
#     #   bf_width = 11 * eTW
#     # ) %>% 
#     dplyr::mutate(
#       bf_width = exp(0.700    + 0.365* log(tot_drainage_areasqkm))
#       ) %>% 
#     dplyr::select(
#       hy_id = id, 
#       lengthkm,
#       tot_drainage_areasqkm,
#       bf_width,
#       geometry = geom
#       )  
#   
#   system.time({
#   
#   # create transect lines
#   transects <- terrainSliceR::cut_cross_sections(
#                       net               = flines,                        # flowlines network
#                       id                = "hy_id",                       # Unique feature ID
#                       cs_widths         = pmax(50, flines$bf_width), # cross section width of each "id" linestring ("hy_id")
#                       num               = 10,                            # number of cross sections per "id" linestring ("hy_id")
#                       smooth            = TRUE,                          # smooth lines
#                       densify           = 3,                             # densify linestring points
#                       rm_self_intersect = TRUE,                          # remove self intersecting transects
#                       fix_braids        = FALSE,                         # whether to fix braided flowlines or not
#                       #### Arguments used for when fix_braids = TRUE
#                       # terminal_id       = NULL, 
#                       # braid_threshold   = NULL,
#                       # version           = 2,
#                       # braid_method      = "comid",
#                       # precision         = 1,
#                       add               = TRUE                           # whether to add back the original data
#                       )
#   })
#   
# 
# 
#   # name of file and path to save flowlines gpkg too
#   out_file <- gsub("nextgen", "transects", nextgen_files[i])
#   out_path <- glue::glue('{transects_dir}{out_file}')
#   
#   logger::log_info("Saving transects:\n{out_path}")
#   
#   # save flowlines to out_path (lynker-spatial/02_flowlines/flowlines_<VPU num>.gpkg)
#   sf::write_sf(
#         dplyr::select(
#           dplyr::mutate(transects,
#                         cs_source = net_source), 
#           hy_id, cs_source, cs_id, cs_measure, cs_length = cs_widths, geometry), 
#       out_path
#       )
#   # sf::write_sf(transects, out_path)
# }