---
title: "braided_transects"
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)

# network <- sf::read_sf("/Users/anguswatters/Desktop/braid_network.gpkg")

thm <- ggplot2::theme_void() 

# net2 <- nhdplusTools::navigate_network(start = 15175471, mode = "UT",  distance_km = 150)
# net3 <- nhdplusTools::navigate_network(start = 18717056, mode = "UT",  distance_km = 30)
# 
# plot(net2$geometry)
# plot(net3$geometry)
# 
# mapview::mapview(net2)
```

```{r, eval = T, echo=F}
make_braids_gif <- function(network,
                            save_path  = NULL,
                            title = "",
                            height     = 8,
                            width      = 10,
                            gif_width  = 1800,
                            gif_height = 1500,
                            delay      = 0.8,
                            legend_pos = "bottom",
                            theme_obj  = NULL,
                            verbose    = FALSE
) {

  # if no save path is given
  if(is.null(save_path)) {
    # save path is current working directory
    save_path <- getwd()
  }


  ubraids <- unique(network$braid_id)

  # this will create a temp folder, but tempdir() won't let you name it:
  temp_dir <- tempdir()

  # this will create a folder within our temp folder, with a name of our choice:
  new_dir <- paste0(temp_dir, "/braid_plots/")

  # check if new temp dir alrteady exists
  if(dir.exists(new_dir)) {

    warning(new_dir, " already exists")

  }

  # create temporary directory
  dir.create(path = new_dir)

  if(verbose) { message("Plotting braids... ")}

  # make names lowercase
  names(network) <- tolower(names(network))

  # unique braid_ids
  ubraids <- unique(network$braid_id)

  ubraids <- ubraids[!grepl("no_braid", ubraids)]
  
  # set geometry name of network to "geometry"
  network <- nhdplusTools::rename_geometry(network, "geometry")
  
  for (i in 1:length(ubraids)) {

    if(verbose) {
      message(ubraids[i], " - (", i, "/", length(ubraids), ")")
    }

    braid_plot <-
      # b %>%
      network %>%
      # dplyr::select(comid, braid_id, geometry) %>%
      ggplot2::ggplot() +
      # ggplot2::geom_sf(ggplot2::aes(fill = braid_id)) +
      ggplot2::geom_sf(ggplot2::aes(color = braid_id)) +
      gghighlight::gghighlight(braid_id == ubraids[i]) +
      ggplot2::labs(
        title = title,
        caption = paste0(i, " / ", length(ubraids)),
        color = "",
        # caption = paste0("(", i, " / ", length(ubraids), ")")
      ) 
    
    if(is.null(theme_obj)) {
      braid_plot <- 
        braid_plot +
        ggplot2::theme_bw() +
        ggplot2::theme(
          plot.caption = ggplot2::element_text(size = 12, face = "bold"),
          legend.position = legend_pos
        )
    } else {
      braid_plot <- 
        braid_plot + 
        theme_obj +
        ggplot2::theme(
          plot.caption = ggplot2::element_text(size = 12, face = "bold"),
          legend.position = legend_pos
        )
    }

    temp_file <- tempfile(pattern =  paste0(ifelse(i < 10, paste0("0", i), i), "_braid"),
                          tmpdir = new_dir,
                          fileext = ".png"
    )

    # Generate a temporary file path
    ggplot2::ggsave(
      filename = temp_file,
      plot = braid_plot,
      height = height,
      width = width,
      scale = 1
    )


  }

  # save_path <- "D:/gif/braid_gif.gif"
  png_files <- sort(list.files(new_dir, full.names = TRUE))

  gifski::gifski(png_files,
                 gif_file = save_path,
                 width    = gif_width,
                 height   = gif_height,
                 delay    = delay
  )

  if(verbose) {
    message("Saving braid gif:\n --- ", save_path)
  }

  # unlink deletes temporary directory holding PNGs
  unlink(new_dir, recursive = TRUE)

}
```

```{r setup, warning=F, message = F}
library(terrainSliceR)
library(dplyr)
library(sf)
library(ggplot2)
library(nhdplusTools)
```

```{r, eval = TRUE, echo= TRUE, warning=F, message = F}
# network <- nhdplusTools::navigate_network(start = 101, mode = "UT", distance_km = 25)

network <- nhdplusTools::navigate_network(start = 18717056, mode = "UT",  distance_km = 50)
# network <- nhdplusTools::navigate_network(start = 18717056, mode = "UT",  distance_km = 30)

# network <- nhdplusTools::navigate_network(start = 15175471, mode = "UT",  distance_km = 150)
# network <- nhdplusTools::navigate_network(start = 101, mode = "UT", distance_km = 55)

flood_plain_sections = 5

network <-
  network %>%
  # https://agupubs.onlinelibrary.wiley.com/doi/full/10.1002/2013WR013916
  dplyr::mutate(
    bf_width = exp(0.700	 + 0.365* log(totdasqkm)),
    cs_width = flood_plain_sections * bf_width
    ) %>% 
  dplyr::select(comid, divergence,bf_width, cs_width, lengthkm, totdasqkm, fromnode, tonode, terminalpa)

# set geometry name of network to "geometry"
network <- nhdplusTools::rename_geometry(network, "geometry")
```

```{r, eval = TRUE, echo = FALSE}
#  filter out a flowline that makes plotting more difficult
net <- dplyr::filter(network, !comid %in% c(1078575, 1078577))

plot(net$geometry)
```


Now let's add cross sections using the algorithm described here (INSERT LINK TO HOME VIGNETTE). 

```{r}
transects <- terrainSliceR::cut_cross_sections(
  net        = net,
  id         = "comid",
  cs_widths  = 200,
  num        = 10,
  fix_braids = FALSE,
  add        = TRUE
  )
```

```{r, eval = T, echo = F}
ggplot2::ggplot() +
  ggplot2::geom_sf(data = net, color = "black") + 
  ggplot2::geom_sf(data = transects, color = "red", alpha = 1) +
  thm
```

Here we have created our cross sections lines with 10 transect lines per COMID/flowline geometry. The problem here is that this section of river is braided and we want to have cross sections extend across multiple flowlines in some cases such that the cross section line represents that width across the braided river sections, instead of having individual transect lines for each of the parallel braided flowlines. 

This presents a problem as braided systems are inherently complex and irregular. If we want to try and extend cross section lines across all flowlines in a given braid, the first thing we need is a way of uniquely identifying each braid and all of the flowlines within that braid. 

To accomplish this, we made use of the flowline `from/tonode` topology relationships, and common graph traveral algorithms (DFS). 

## Show network as a Directed Acyclic Graph

## Show network represented as an Undirected Graph

## Show what DFS algo produces

The `find_braids()` function can be used to identify and assign a `braid_id` to each flowline in a NHDPlus network dataset that includes a comid, fromnode, tonode, and divergence columns. 
```{r, eval = T, echo = T}
# add braid_id column to network
braids <- terrainSliceR::find_braids(
    network     = net, 
    add         = TRUE,
    nested      = TRUE
  )

length(unique(braids$braid_id))
```

```{r, echo = FALSE, eval = FALSE}
plot_braids <- terrainSliceR::find_braids(
              network = net,
              nested  = FALSE,
              add     =  TRUE
            )
# plot_braids$braid_id %>% unique() %>% length()
# plot_braids %>% 
#   dplyr::rename(geometry = geom) %>% 
#   ggplot2::ggplot() +
#   ggplot2::geom_sf(ggplot2::aes(color = braid_id))+
#   gghighlight::gghighlight(braid_id == "braid_1")
make_braids_gif(
  network    = plot_braids,
  save_path  = "/Users/anguswatters/Desktop/braid_vignette_gif.gif",
  title      = "",
  height     = 8,
  width      = 10,
  gif_width  = 1800,
  gif_height = 1500,
  delay      = 0.8,
  legend_pos = "bottom",
  theme_obj  = NULL,
  verbose    = FALSE
  )
```

![Animation showing braid IDs](/Users/anguswatters/Desktop/braid_vignette_gif.gif)

Now we have a method for identifying *which* flowlines are part of braid. Next, we will find the cross section lines that are on these braided flowlines, and work on extending them to encompass the entire width of the river by crossing across the rest of the braided flowlines. 


First we want to join our transect lines with the sections of rivers with a braid_id not equal to "no_braid" (ID for flowlines that are NOT part of a braid)

So we seperate the braided flowlines from the non braided flowlines:
```{r, eval = T, echo = T}
# not braided flowlines
not_braids <-  dplyr::filter(braids, braid_id == "no_braid")

# trim down network to just the braided parts, and add a comid count to separate out multibraids
braids <- dplyr::filter(braids, braid_id != "no_braid") 

# add connected component "component_id" column
braids <- find_connected_components(braids)
```

```{r, eval = T, echo = F}
# tmp = braid_lengths(braids, multibraid = TRUE)
# braid_lengths(braids, multibraid = F)$braid_length
# tmp$braid_length %>%unique() %>% round(2) %>%   sort()
# braid_threshold = 15000
braid_threshold = 150000
# all(tmp$braid_length <= braid_threshold)

# remove braids that have a total flowline length greater than braid_threshold
# braids <- braid_thresholder3(
#   x         = braids, 
#   originals = not_braids, 
#   threshold = braid_threshold,
#   verbose   = TRUE
# )

# # remove braids that have a total flowline length greater than braid_threshold
braids <- terrainSliceR:::braid_thresholder(
  x         = braids,
  originals = not_braids,
  threshold = braid_threshold,
  verbose   = TRUE
)

# reassign braids and not_braids datasets to the updated values in 'braids' list (REASSIGNMENT ORDER MATTERS HERE)
not_braids <- braids$not_braids
braids     <- braids$braids
```

Then join the braided flowlines with the transects 
```{r, eval = T, echo = T}
cross_sections <- 
  transects %>%
  dplyr::filter(hy_id %in% braids$comid) %>%
  dplyr::left_join(
  sf::st_drop_geometry(
    dplyr::select(
      braids, comid, braid_id, is_multibraid
    )
  ),
  by = c("hy_id" = "comid")
  ) %>% 
  dplyr::arrange(-totdasqkm)
```


That gives us this set of cross sections:
```{r, eval = T, echo = F}
ggplot2::ggplot() +
  ggplot2::geom_sf(data = net, color = "black") + 
  ggplot2::geom_sf(data = cross_sections, color = "red", alpha = 1) +
  thm
```

We can now iterate over all of these cross sections and determine which cross sections should be extended, in what order, and by what distance.
```{r}
unique(cross_sections$braid_id)[1:5]
```


```{r}
# for(i in 1:nrow(cross_sections)) {
i = 1222

# comid of transect line
com <- cross_sections$hy_id[i]

# braid ID of interest
braids_of_interest <- cross_sections$braid_id[i]
braids_of_interest

# # get the component ID of current COMID
comp_id <- braids$component_id[braids$comid == com]

# other geometries to cut across with transects
others <- terrainSliceR:::get_geoms_to_cut(
            x            = braids,
            id           = com,
            braid_id     = braids_of_interest,
            # component    = NULL,
            component    = comp_id,
            # method       = "neighbor"
            method       = "comid"
          )

plot(others$geometry)
```

In the image below, the red flowline is the COMID that we will be augmenting the transect lines for and all of the blue flowlines are the flowlines that are eligible to be cut through via the transect extension algorithm.
```{r, eval = T, echo = F}
ggplot2::ggplot() +
  # ggplot2::geom_sf(data = net, color = "black") + 
    ggplot2::geom_sf(data = dplyr::bind_rows(
                              dplyr::mutate(
                                others,
                                grouping = "Geoms to cut"
                                ),
                              dplyr::mutate(
                                dplyr::filter(braids, comid == com),
                                grouping = "Origin"
                                )
                              ), 
                     ggplot2::aes(color = grouping)) + 
  # ggplot2::geom_sf(data = dplyr::mutate(braids,
  #                       grouping = dplyr::case_when(
  #                         comid == com ~ "origin",
  #                         comid %in% others$comid ~ "geoms_to_cut",
  #                         TRUE ~ "other"
  #                       )), 
  #                     ggplot2::aes(color = grouping)) + 
  ggplot2::geom_sf(data = cross_sections[i, ], color = "black", alpha = 1) +
  thm
```

```{r, eval = F, echo = F}
make_geoms_to_cut_gif(
  full_network    = net,
  braid_flowlines = braids,
  transect_lines = cross_sections,
  cut_method = "comid",
  one_transect_per = TRUE,
  save_path  = "/Users/anguswatters/Desktop/geoms_to_cut_gif.gif",
  title      = "",
  height     = 8,
  width      = 10,
  gif_width  = 1800,
  gif_height = 1500,
  delay      = 0.7,
  legend_pos = "bottom",
  theme_obj  = NULL,
  verbose    = FALSE
  )
```

![Animation highlight which flowlines to cut across](/Users/anguswatters/Desktop/geoms_to_cut_gif.gif)

```{r, eval = F, echo = F}
make_geoms_to_cut_gif <- function(
                            full_network,
                            braid_flowlines,
                            transect_lines,
                            cut_method = "comid",
                            one_transect_per = TRUE,
                            save_path  = NULL,
                            title = "",
                            height     = 8,
                            width      = 10,
                            gif_width  = 1800,
                            gif_height = 1500,
                            delay      = 0.5,
                            legend_pos = "bottom",
                            theme_obj  = NULL,
                            verbose    = FALSE
) {
  
  # full_network <- net
  # braid_flowlines <- braids
  # transect_lines <- cross_sections
  # save_path  = "/Users/anguswatters/Desktop/geoms_to_cut_gif.gif"
 
  # if no save path is given
  if(is.null(save_path)) {
    # save path is current working directory
    save_path <- getwd()
  }


  # this will create a temp folder, but tempdir() won't let you name it:
  temp_dir <- tempdir()

  # this will create a folder within our temp folder, with a name of our choice:
  new_dir <- paste0(temp_dir, "/geoms_to_cut_plots/")

  # check if new temp dir alrteady exists
  if(dir.exists(new_dir)) {

    warning(new_dir, " already exists")

  }

  # create temporary directory
  dir.create(path = new_dir)

  if(verbose) { message("Plotting geometries to cut across... ")}

  # make names lowercase
  names(full_network) <- tolower(names(full_network))
  
  # set geometry name of network to "geometry"
  full_network <- nhdplusTools::rename_geometry(full_network, "geometry")

  # if missing connected component "component_id" column, try to add it
  if(!"component_id" %in% names(braid_flowlines)) {
     # add connected component "component_id" column
    braid_flowlines <- find_connected_components(braid_flowlines)
  }
  
  # if only one transect plot should be created per COMID
  if(one_transect_per) {
    transect_lines <- 
      transect_lines %>% 
      dplyr::group_by(hy_id) %>% 
      dplyr::slice(1) %>% 
      dplyr::ungroup()
  }
  
  for (i in 1:nrow(transect_lines)) {

    if(verbose) {
      message(i, "/", nrow(transect_lines))
    }
    
    # comid of transect line
    com <- transect_lines$hy_id[i]
    
    # braid ID of interest
    braids_of_interest <- transect_lines$braid_id[i]
    
    # # get the component ID of current COMID
    comp_id <- braid_flowlines$component_id[braid_flowlines$comid == com]
    
    # other geometries to cut across with transects
    others <- terrainSliceR:::get_geoms_to_cut(
                x            = braid_flowlines,
                id           = com,
                braid_id     = braids_of_interest,
                component    = comp_id,
                # method       = "neighbor"
                method       = cut_method
              )
    
     braid_flowlines_plot <-
        ggplot2::ggplot() +
        ggplot2::geom_sf(data = full_network, color = "black") + 
        ggplot2::geom_sf(data = dplyr::bind_rows(
                              dplyr::mutate(
                                others,
                                grouping = "Geoms to cut"
                                ),
                              dplyr::mutate(
                                dplyr::filter(braid_flowlines, comid == com),
                                grouping = "Origin"
                                )
                              ), 
                     ggplot2::aes(color = grouping)) + 
        # ggplot2::geom_sf(data = dplyr::mutate(braid_flowlines,
        #                                         grouping = dplyr::case_when(
        #                                           comid == com ~ "Origin COMID",
        #                                           TRUE ~ "COMIDs to cut across"
        #                                           )
        #                                         ), 
        #                             ggplot2::aes(color = grouping)
        #                                          ) + 
        ggplot2::geom_sf(
          data = sf::st_centroid(transect_lines[i, ]),# data = transect_lines$geometry[i],
          color = "black",
          size = 2, # size = 3,
          # shape = 9,# shape = 4,# shape = 8, # shape = 26, # shape = 15, # shape= 13,
          alpha = 1
        ) +
        ggplot2::labs(
          title = title,
          color = "",
          caption = paste0(i, " / ", nrow(transect_lines))
        ) 

    if(is.null(theme_obj)) {
      braid_flowlines_plot <- 
        braid_flowlines_plot +
        ggplot2::theme_bw() +
        ggplot2::theme(
          plot.caption = ggplot2::element_text(size = 12, face = "bold"),
          # plot.caption = ggplot2::element_text(size = 12, hjust = 0.5, face = "bold"),
          legend.position = legend_pos,
          legend.direction = "vertical"
        )
    } else {
      braid_flowlines_plot <- 
        braid_flowlines_plot + 
        theme_obj +
        ggplot2::theme(
          plot.caption = ggplot2::element_text(size = 12, face = "bold"),
          # plot.caption = ggplot2::element_text(size = 12, hjust = 0.5, face = "bold"),
          legend.position = legend_pos,
          legend.direction = "vertical"
        )
    }

    temp_file <- tempfile(pattern =  paste0(ifelse(i < 10, paste0("0", i), i), "_braid_flowlines"),
                          tmpdir = new_dir,
                          fileext = ".png"
    )

    # Generate a temporary file path
    ggplot2::ggsave(
      filename = temp_file,
      plot = braid_flowlines_plot,
      height = height,
      width = width,
      scale = 1
    )


  }

  # save_path <- "D:/gif/braid_gif.gif"
  png_files <- sort(list.files(new_dir, full.names = TRUE))

  # sort file paths based on the extracted numbers
  plot_order <- as.numeric(gsub('.*geoms_to_cut_plots//(\\d+)_braid_flowlines.*', '\\1', png_files))
  # plot_order <- as.numeric(stringr::str_extract(png_files, "(?<=geoms_to_cut_plots//)(\\d+)(?=_braid_flowlines)"))
  
  png_files <- png_files[order(plot_order)]
  
  gifski::gifski(png_files,
                 gif_file = save_path,
                 width    = gif_width,
                 height   = gif_height,
                 delay    = delay
  )

  if(verbose) {
    message("Saving flowlines to cut gif:\n --- ", save_path)
  }

  # unlink deletes temporary directory holding PNGs
  unlink(new_dir, recursive = TRUE)

}
```


If we look at an individual COMID in a given braid, and we decide we want to extend our cross sections for that COMID outward to try and cut across other flowlines within the same braided system, we now have a method for selecting which *other* COMIDs are candidates to cut across. 

If we didn't come up with a way of distinguishing which flowlines our extended transect was allowed to cross over, then our algorithm would ultimately try and extend each transect out indefinitely/attempt to cut across ALL other flowlines in the network. This wouldn't make hydrologic or computational sense.

Determining the middle flowline in a braided system was challenging at first but a simple solution was found. From each transect line, we can count the number of intersections on either side of the transect when we extend the transect line out as far as needed to cross all neighboring flowlines.

## Order of extensions
When ever we take a transect line and extend it outward in either direction, we run into the possibility that our newly extended transect line will now violate one of the fundemental properties of our cross sections:

1. The extended transect line now intersects with *another flowline outside of the braided area*
2. The extended transect line now intersects with *another transect line*
3. The extended transect line now intersects with *its own COMID/flowline*

Moreover, some flowlines in a braided system should be given priority over other flowlines when it comes to the order that their transects are extended.
Transect lines in the *middle* of a braided system should be extended first as they are likely to produce the most representative transect line, so we want to prioritize extending these first.

Transect lines were classified by their relative position within the braided system and were put into one of the following 5 groups:

1. No intersection - transect line never intersects another flowline after maximum extension in both directions

2. Outer single - Transect line will intersect zero flowlines in one direction, and exactly one other flowline in the other direction, this is the case when a braid has just 2 parts.

3. Outer multiple - Transect line will intersect zero flowlines in one direction, and more than one other flowline in the other direction

4. Inner - Transect line is in the middle of a braid. There are 2 scenarios, either there is an *even* or an *odd* number of parallel flowlines in the braid:
 
 - **Odd case:** same number of intersections in both directions (intersects_count1 == intersects_count2) 
 
 - **Even case:** the maximum number of counted intersections minus one equals the minimum number of counted intersections (max(intersects_count1, intersects_count2) - 1 == min(intersects_count1, intersects_count2))


5. In between - Transect line is between the middle and the outer portion of the braid

```{r}
# column to fill out relative position of cross section
cross_sections$position <- NA

for(i in 1:nrow(cross_sections)) {

  # comid of transect line
  com <- cross_sections$hy_id[i]
  
  # braid ID of interest
  braids_of_interest <- cross_sections$braid_id[i]
  # braids_of_interest
  
  # # get the component ID of current COMID
  comp_id <- braids$component_id[braids$comid == com]
  
  # other geometries to cut across with transects
  others <- terrainSliceR:::get_geoms_to_cut(
              x            = braids,
              id           = com,
              braid_id     = braids_of_interest,
              # component    = NULL,
              component    = comp_id,
              # method       = "neighbor"
              method       = "comid"
            )
  
    # geoms_to_cut  = others
  extend_maps <- terrainSliceR:::geos_augment_transect(
      cross_section = cross_sections[i, ],
      geoms_to_cut  = geos::as_geos_geometry(others$geometry),
      geom_ids      = others$comid,
      max_distance  = NULL, 
      by            = 1, 
      as_df         = FALSE,
      carry_geom    = FALSE
    )
    
    # extend_maps$head$as_list()
    position <- extend_maps$head$get("position")
    
    cross_sections$position[i] <- position
    
}

ggplot2::ggplot() +
  ggplot2::geom_sf(data = net, color = "black") + 
  ggplot2::geom_sf(data = cross_sections, ggplot2::aes(color = position)) +
  # ggplot2::geom_sf(data = cross_sections[i, ], color = "limegreen", alpha = 1) +
  thm +
  ggplot2::theme(
      plot.caption = ggplot2::element_text(size = 12, face = "bold"),
      # plot.caption = ggplot2::element_text(size = 12, hjust = 0.5, face = "bold"),
      legend.position = "right",
      legend.direction = "vertical"
    )
```


In order to get the best set of final transect lines, we prioritize the "inner" transect lines and work on extending these ones first. 


```{r, eval = F, echo = F}
xs <- cross_sections
library(fastmap)

# keep track of all original crossections
all_xs <- paste0(xs$hy_id, "_", xs$cs_id)

# column to store the relative position within the braid of the flowline we're on 
xs$relative_position <- NA

# flag determining whether transect should/has been replaced
xs$changed <- FALSE

# flag determining whether transect is to be processed in a future step after middle flowlines are processed
xs$pending <- TRUE

# flag determining whether transect is to be processed in a future step after middle flowlines are processed
xs$pending <- TRUE

# empty columns to store number of head/tail intersections
xs$head_cuts     <- NA
xs$tail_cuts     <- NA

# empty columns to store distance needed to extend from head/tail of line
xs$head_distance <- NA
xs$tail_distance <- NA

for(i in 1:nrow(xs)) {
    # message("i: ", i, "/", nrow(xs))
    # i = 1

    # comid of transect line
    com <- xs$hy_id[i]
    
    # braid ID of interest
    bid <- xs$braid_id[i]
    
    # get the component ID of current COMID
    comp_id <- braids$component_id[braids$comid == com]
  
    # other geometries to cut across with transects
    others <- terrainSliceR:::get_geoms_to_cut(
                x            = braids,
                id           = com,
                braid_id     = bid,
                component    = comp_id,
                method       = "comid"
              )
    
    # aug_time1 <- Sys.time()

    # geoms_to_cut  = others
    extend_maps <- terrainSliceR:::geos_augment_transect(
      cross_section = xs[i, ],
      geoms_to_cut  = geos::as_geos_geometry(others$geometry),
      geom_ids      = others$comid,
      max_distance  = NULL, 
      by            = 1, 
      as_df         = FALSE,
      carry_geom    = FALSE
    )
    
    position <- extend_maps$head$get("position")
    
    # if a flowline on the inner portion of a braid, make extension and insert
    if(position == "inner") {
      
      # extend line out by total distance key values in head and tail maps
      res_geom <- terrainSliceR:::geos_extend_transects(
        starter_line   = geos::as_geos_geometry(xs$geometry[i]),
        head_distance  = extend_maps$head$get("total_distance"),
        tail_distance  = extend_maps$tail$get("total_distance"),
        extra_distance = xs$cs_widths[i]/2
      )
      # ONLY UPDATE geometry if it does NOT intersect with any of the other multibraid transects that have been changed so far (AND LEAVE OUT SELF)
      if(
        !geos::geos_intersects_any(
          res_geom,
          geos::as_geos_geometry(dplyr::filter(xs[-i,], changed))
        )
      )  
        {
        
        # updatem geometry with new, extended cross section
        xs$geometry[i] <- sf::st_geometry(
          sf::st_as_sf(res_geom)
        )
        
        # flag determining whether transect should be replaced
        xs$changed[i] <- TRUE
        
      }
      
    } 
    
    # update relative position column
    xs$relative_position[i] <- extend_maps$head$get("position")
    
    # UPDATE "pending" value to reflect that this is a inner flowline and it should be processed at once
    xs$pending[i] <- extend_maps$head$get("pending")
    
    # update head/tail distances values in dataframe w/ values from head/tail hashmaps
    xs$head_distance[i] <- extend_maps$head$get("total_distance")
    xs$tail_distance[i] <- extend_maps$tail$get("total_distance")
    
    # update head_cuts/tail_cuts counts (intersection counts) values dataframe w/ values from head/tail hashmaps
    xs$head_cuts[i] <- extend_maps$head$get("count")
    xs$tail_cuts[i] <- extend_maps$tail$get("count")
   
  }
```


```{r}
ggplot2::ggplot() +
  ggplot2::geom_sf(data = net, color = "black") + 
  ggplot2::geom_sf(data = xs, ggplot2::aes(color = position)) +
  # ggplot2::geom_sf(data = cross_sections[i, ], color = "limegreen", alpha = 1) +
  thm +
  ggplot2::theme(
      plot.caption = ggplot2::element_text(size = 12, face = "bold"),
      # plot.caption = ggplot2::element_text(size = 12, hjust = 0.5, face = "bold"),
      legend.position = "right",
      legend.direction = "vertical"
    )
```

















